<!DOCTYPE html>
<html lang="es-CO">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tema 12.3 Subtema 12.3.1</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            line-height: 1.8;
            font-size: 18px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .content {
            color: #333;
            text-align: justify;
        }
        .instructions {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .instructions h2 {
            margin-top: 0;
            color: #2980b9;
            font-size: 16px;
        }
        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tema 12.3 Subtema 12.3.1</h1>
        
        <div class="instructions">
            <h2>ğŸ“¢ Instrucciones para escuchar con voz Salome (Colombia)</h2>
            <ol>
                <li>Haz clic derecho en esta pÃ¡gina</li>
                <li>Selecciona <strong>"Leer en voz alta"</strong> o presiona <strong>Ctrl + Shift + U</strong></li>
                <li>En el panel de lectura, haz clic en <strong>Opciones de voz</strong> (âš™ï¸)</li>
                <li>Selecciona la voz: <strong>es-CO-SalomeNeural (Colombia)</strong></li>
                <li>Ajusta la velocidad a tu preferencia</li>
                <li>Presiona <strong>Play â–¶ï¸</strong> para comenzar</li>
            </ol>
        </div>
        
        <div class="content">
            Guion de Video: Saga Patterns DuraciÃ³n: 32 minutos Nivel: Avanzado Requisitos previos: Event-Driven Architecture, CQRS, Microservices --- ## IntroducciÃ³n - El Problema de Transacciones Distribuidas [PANTALLA: TÃ­tulo animado "Saga Patterns: Transacciones Distribuidas"] ğŸ¬ NarraciÃ³n: "Bienvenidos al patrÃ³n mÃ¡s crÃ­tico en microservicios: Saga Patterns. Imagina que estÃ¡s comprando en Amazon. Haces un pedido. Amazon necesita: 1. Crear la orden 2. Reservar inventario 3. Procesar tu pago 4. Programar el envÃ­o En una aplicaciÃ³n monolÃ­tica, esto serÃ­a una transacciÃ³n ACID simple: todo o nada. Pero en microservicios, cada uno de estos pasos estÃ¡ en un servicio diferente, con su propia base de datos. No existe 'BEGIN TRANSACTION' distribuido sin complejidades enormes. Â¿QuÃ© pasa si el inventario se reserva, el pago se procesa... y luego el servicio de envÃ­o estÃ¡ caÃ­do? Tienes dinero del cliente, inventario bloqueado, pero no puedes cumplir la orden. Hoy veremos cÃ³mo Saga Patterns resuelve esto con dos enfoques: Choreography y Orchestration." [VISUAL: Diagrama de microservicios con DBs independientes] --- ## El Problema: CÃ³digo Incorrecto [PANTALLA: CÃ³digo Java] ğŸ¬ NarraciÃ³n: "Empecemos viendo el error mÃ¡s comÃºn que veo en arquitecturas de microservicios." [VISUAL: CÃ³digo problemÃ¡tico] ``java @Transactional // âŒ Esto NO funciona en microservicios public class OrderService { public Order createOrder(OrderRequest request) { // Step 1. Save order (DB1) Order order = orderRepository.save(new Order(request)); // Step 2: Reserve inventory (DB2 - otro servicio!) inventoryService.reserveStock(order.getItems()); // Step 3: Charge payment (DB3 - otro servicio!) PaymentResult payment = paymentService.charge( order.getCustomerId(), order.getTotal() ); if (!payment.isSuccess()) { throw new PaymentException(); // âŒ Rollback? } return order; } } ` [ANIMACIÃ“N: Mostrar problema con rollback] ğŸ¬ NarraciÃ³n: "AquÃ­ hay 3 problemas fatales: Problema 1. @Transactional solo controla la DB local de OrderService. No puede hacer rollback de inventoryService ni paymentService que estÃ¡n en otras DBs. Problema 2: Si paymentService.charge() falla, Spring hace rollback de orderRepository.save(). Perfecto. Pero... Â¿quÃ© pasa con inventoryService.reserveStock() que ya ejecutÃ³? El stock queda reservado permanentemente. Estado inconsistente. Problema 3: Acoplamiento fuerte. OrderService conoce y depende directamente de InventoryService y PaymentService." [VISUAL: Timeline del fallo] ` Timeline: 1. orderRepository.save() â†’ âœ… Order saved in DB1 2. inventoryService.reserveStock() â†’ âœ… Stock reserved in DB2 3. paymentService.charge() â†’ âŒ FAIL 4. Spring rollback â†’ âœ… Order deleted from DB1 5. âš ï¸ Stock STILL reserved in DB2 â†’ INCONSISTENT STATE Result: Order cancelled, but inventory locked forever ` --- ## SoluciÃ³n 1. Choreography Saga [TRANSICIÃ“N: Arquitectura Choreography] ğŸ¬ NarraciÃ³n: "La primera soluciÃ³n es Choreography: los servicios se coordinan mediante eventos, sin un coordinador central." [VISUAL: Diagrama animado] ` Choreography Saga - Event-Driven Coordination â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ OrderService â”‚ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ 1. Save order (PENDING) â”‚ â–¼ OrderCreated â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â–¼ â–¼ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ InventoryServiceâ”‚ â”‚PaymentServiceâ”‚ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”‚ â–¼ â–¼ StockReserved PaymentCharged â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â–¼ ShippingService ` [DEMO: CÃ³digo TypeScript] `typescript // ========== Choreography Implementation ========== class OrderService { async createOrder(command: CreateOrderCommand): Promise<void> { // 1. Save order with PENDING status const order = await this.orderRepo.save({ id: generateId(), customerId: command.customerId, items: command.items, status: 'PENDING', // âœ… Not CONFIRMED yet total: calculateTotal(command.items) }); // 2. Publish event await this.eventBus.publish({ type: 'OrderCreated', orderId: order.id, customerId: order.customerId, items: order.items, timestamp: new Date() }); } // Compensation: Cancel if payment fails @EventHandler('PaymentFailed') async onPaymentFailed(event: PaymentFailedEvent): Promise<void> { await this.orderRepo.update(event.orderId, { status: 'CANCELLED', cancelReason: event.reason }); console.log(Order ${event.orderId} cancelled: ${event.reason}); } } class InventoryService { @EventHandler('OrderCreated') async onOrderCreated(event: OrderCreatedEvent): Promise<void> { try { // Reserve stock await this.reserveStock(event.items); // Success â†’ Publish await this.eventBus.publish({ type: 'StockReserved', orderId: event.orderId, items: event.items }); } catch (error) { // Failed â†’ Publish failure await this.eventBus.publish({ type: 'StockReservationFailed', orderId: event.orderId, reason: error.message }); } } // Compensation: Release stock if payment fails @EventHandler('PaymentFailed') async onPaymentFailed(event: PaymentFailedEvent): Promise<void> { await this.releaseReservation(event.orderId); console.log(Stock released for order ${event.orderId}); } } class PaymentService { @EventHandler('StockReserved') async onStockReserved(event: StockReservedEvent): Promise<void> { try { await this.processPayment(event.orderId, event.total); await this.eventBus.publish({ type: 'PaymentCharged', orderId: event.orderId }); } catch (error) { await this.eventBus.publish({ type: 'PaymentFailed', orderId: event.orderId, reason: error.message }); } } } ` ğŸ¬ NarraciÃ³n: "Â¿Ven la diferencia? Cada servicio: 1. Escucha eventos 2. Ejecuta SU transacciÃ³n local 3. Publica evento de Ã©xito o fallo 4. Define compensaciÃ³n si algo falla despuÃ©s No hay coordinador. Los servicios no se conocen entre sÃ­. Solo eventos." [ANIMACIÃ“N: Flujo con fallo] ` Failure Flow: 1. OrderCreated â†’ OrderService saves PENDING 2. StockReserved â†’ Inventory reserves 3. PaymentFailed â†’ Payment service fails 4. PaymentFailed event â†’ Triggers compensations: - InventoryService: Release stock - OrderService: Cancel order 5. âœ… Consistent state: Order cancelled, stock available ` --- ## SoluciÃ³n 2: Orchestration Saga [TRANSICIÃ“N: Arquitectura Orchestration] ğŸ¬ NarraciÃ³n: "Choreography funciona, pero tiene problemas: es difÃ­cil ver el flujo completo, no hay timeout global, debugging es complicado. La alternativa es Orchestration: un coordinador central que dirige toda la saga." [VISUAL: Diagrama Orchestration] ` Orchestration Saga - Centralized Coordination â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Saga Orchestrator â”‚ â”‚ (Coordinator) â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ â”‚ â”‚ â–¼ â–¼ â–¼ OrderService InventoryService PaymentService â”‚ â”‚ â”‚ â–¼ â–¼ â–¼ Create Order Reserve Stock Charge Payment ` [DEMO: CÃ³digo Java] `java // ========== Orchestration Implementation ========== public class CreateOrderSagaOrchestrator { private static final Duration SAGA_TIMEOUT = Duration.ofMinutes(5); private final OrderService orderService; private final InventoryService inventoryService; private final PaymentService paymentService; private final SagaRepository sagaRepo; public SagaResult execute(CreateOrderCommand command) { var sagaId = UUID.randomUUID().toString(); var startTime = Instant.now(); // Save saga state sagaRepo.save(new SagaState(sagaId, "STARTED", command)); try { // Step 1. Create order var orderId = executeStep(sagaId, "CreateOrder", () -> orderService.create(command) ); // Check timeout if (Duration.between(startTime, Instant.now()).compareTo(SAGA_TIMEOUT) > 0) { throw new SagaTimeoutException("Saga timeout"); } // Step 2: Reserve stock executeStep(sagaId, "ReserveStock", () -> inventoryService.reserveStock(orderId, command.items()) ); // Step 3: Charge payment executeStep(sagaId, "ChargePayment", () -> paymentService.charge(orderId, command.total()) ); // âœ… Success sagaRepo.update(sagaId, "COMPLETED"); return SagaResult.success(orderId); } catch (Exception e) { // âŒ Failed â†’ Compensate compensate(sagaId); return SagaResult.failure(e.getMessage()); } } private <T> T executeStep(String sagaId, String stepName, Supplier<T> action) { try { T result = action.get(); // Save successful step sagaRepo.addStep(sagaId, new SagaStep(stepName, "COMPLETED", result)); return result; } catch (Exception e) { // Save failed step sagaRepo.addStep(sagaId, new SagaStep(stepName, "FAILED", e.getMessage())); throw e; } } private void compensate(String sagaId) { var saga = sagaRepo.findById(sagaId); // Compensate in REVERSE order var completedSteps = saga.getSteps() .stream() .filter(s -> s.status().equals("COMPLETED")) .toList() .reversed(); for (var step : completedSteps) { try { compensateStep(step); } catch (Exception e) { // Log but continue compensating other steps logger.error("Failed to compensate {}: {}", step.name(), e.getMessage()); } } sagaRepo.update(sagaId, "COMPENSATED"); } private void compensateStep(SagaStep step) { switch (step.name()) { case "CreateOrder" -> orderService.cancel(step.result()); case "ReserveStock" -> inventoryService.releaseReservation(step.result()); case "ChargePayment" -> paymentService.refund(step.result()); } } } ` ğŸ¬ NarraciÃ³n: "El Orchestrator tiene visibilidad completa. Sabe quÃ© steps ejecutÃ³, cuÃ¡les fallaron, y puede compensar en orden inverso. AdemÃ¡s, puede implementar timeout global, retry logic con exponential backoff, y almacenar el estado de la saga para recovery si el server crashea." [DEMO: Retry con backoff] `typescript private async executeStepWithRetry<T>( sagaId: string, stepName: string, action: () => Promise<T> ): Promise<T> { const MAX_RETRIES = 3; const RETRY_DELAYS = [1000, 2000, 4000]; // Exponential backoff for (let attempt = 0; attempt < MAX_RETRIES; attempt++) { try { return await action(); } catch (error) { // Business error â†’ No retry if (error instanceof BusinessError) { throw error; } // Transient error â†’ Retry if (attempt < MAX_RETRIES - 1) { await sleep(RETRY_DELAYS[attempt]); console.log(Retrying ${stepName} (attempt ${attempt + 2})); continue; } throw error; } } } ` --- ## ComparaciÃ³n y Trade-offs [PANTALLA: Tabla comparativa] ğŸ¬ NarraciÃ³n: "Â¿CuÃ¡l usar? Depende de tus requisitos." [VISUAL: Tabla animada] ` â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ Aspecto â”‚ Choreography â”‚ Orchestration â”‚ â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤ â”‚ CoordinaciÃ³n â”‚ Descentralizada â”‚ Centralizada â”‚ â”‚ Acoplamiento â”‚ âœ… Bajo â”‚ âš ï¸ Alto â”‚ â”‚ Visibilidad â”‚ âŒ DifÃ­cil â”‚ âœ… FÃ¡cil â”‚ â”‚ Testing â”‚ âŒ Complejo â”‚ âœ… Simple â”‚ â”‚ Timeout global â”‚ âŒ No â”‚ âœ… SÃ­ â”‚ â”‚ Retry logic â”‚ âš ï¸ DifÃ­cil â”‚ âœ… FÃ¡cil â”‚ â”‚ Escalabilidad â”‚ âœ… Alta â”‚ âš ï¸ Media â”‚ â”‚ Debugging â”‚ âŒ DifÃ­cil â”‚ âœ… FÃ¡cil â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ` ğŸ¬ NarraciÃ³n: "Usa Choreography cuando: - Workflow es simple (2-4 steps) - Servicios son muy independientes - Desacoplamiento es crÃ­tico - Tolerancia a eventual consistency alta Ejemplos: Notificaciones, analytics, logs. Usa Orchestration cuando: - Workflow es complejo (5+ steps) - Requieres timeout preciso - Debugging y monitoring son prioritarios - TransacciÃ³n es crÃ­tica (pagos, finanzas) Ejemplos: Pedidos e-commerce, reservas, procesos bancarios." [DEMO: CÃ³digo real] ğŸ¬ NarraciÃ³n: "En la prÃ¡ctica, muchas empresas usan AMBOS. Netflix usa Choreography para eventos de dominio (usuario vio video â†’ actualizar recomendaciones). Pero usa Orchestration para procesos crÃ­ticos como facturaciÃ³n." --- ## CompensaciÃ³n Avanzada y Resumen [PANTALLA: CompensaciÃ³n avanzada] ğŸ¬ NarraciÃ³n: "Un concepto crÃ­tico: la compensaciÃ³n NO siempre es rollback perfecto." [VISUAL: Ejemplos no compensables] ` Operaciones NO Compensables Perfectamente: 1. âŒ Email enviado â†’ No puedes "des-enviar" un email â†’ CompensaciÃ³n: Enviar email de cancelaciÃ³n 2. âŒ Pago procesado por Stripe â†’ No puedes hacer rollback instantÃ¡neo â†’ CompensaciÃ³n: Iniciar refund (tarda 5-10 dÃ­as) 3. âŒ Stock fÃ­sico vendido y enviado â†’ Producto ya saliÃ³ del warehouse â†’ CompensaciÃ³n: Esperar devoluciÃ³n o compensar con crÃ©dito 4. âŒ NotificaciÃ³n push enviada â†’ Usuario ya la vio â†’ CompensaciÃ³n: Enviar actualizaciÃ³n ` ğŸ¬ NarraciÃ³n: "Por eso en Saga Patterns hablamos de 'compensaciÃ³n' y no 'rollback'. Es una transacciÃ³n INVERSA, pero no siempre restaura el estado exacto previo. A veces necesitas Forward Recovery: en lugar de cancelar todo, completar la saga de forma alternativa." [EJEMPLO: Forward Recovery] `python # Forward Recovery Example async def book_flight_saga(): try: # Preferred airline await book_flight(airline='United') except NoSeatsAvailableError: # Forward recovery: Try alternative await book_flight(airline='American') # âœ… Continue saga `` ğŸ¬ NarraciÃ³n: "Recapitulemos: âœ… Saga Pattern: Transacciones distribuidas como secuencia de transacciones locales âœ… Choreography: Eventos, desacoplamiento, difÃ­cil debugging âœ… Orchestration: Coordinador central, fÃ¡cil debugging, acoplamiento âœ… CompensaciÃ³n: TransacciÃ³n inversa, no siempre rollback perfecto âœ… Forward Recovery: Completar saga de forma alternativa En el prÃ³ximo video implementaremos Sagas con frameworks reales: Temporal, Camunda, y exploraremos tecnologÃ­as de mensajerÃ­a como Kafka y RabbitMQ. Â¡Hasta la prÃ³xima!" [PANTALLA: Recursos] - ğŸ“š Ejercicios: Food delivery Choreography, Bank transfer Orchestration - ğŸ’¡ Proyecto: Concert ticket reservation con timeout y compensaciÃ³n - ğŸ”— Recursos: Temporal, Camunda, Saga Pattern papers - â–¶ï¸ PrÃ³ximo: Messaging Technologies (Kafka, RabbitMQ, EventStoreDB) --- ## Recursos Visuales ### Animaciones Clave: 1. Problema: TransacciÃ³n distribuida fallando sin rollback 2. Choreography: Eventos fluyendo entre servicios con compensaciÃ³n 3. Orchestration: Coordinador ejecutando steps secuencialmente 4. ComparaciÃ³n: Side-by-side Choreography vs Orchestration 5. Forward Recovery: Intentando alternativas en lugar de cancelar ### CÃ³digo a Mostrar: - TypeScript: Choreography completa con OrderService, InventoryService, PaymentService - Java: Orchestrator con retry, timeout, compensaciÃ³n - Python: Forward recovery con fallback ### Demos en Vivo: 1. Choreography saga ejecutÃ¡ndose (mostrar eventos en logs) 2. Orchestration saga con fallo en step 2 â†’ CompensaciÃ³n automÃ¡tica 3. Retry con exponential backoff 4. Saga state guardado en DB para recovery ### Diagramas: 1. Microservices con DBs independientes (el problema) 2. Choreography flow con eventos 3. Orchestration flow con coordinador central 4. CompensaciÃ³n en orden inverso 5. Forward recovery decision tree ## Notas para el Editor - Resaltar visualmente diferencia Choreography (descentralizado) vs Orchestration (centralizado) - AnimaciÃ³n de compensaciÃ³n ejecutÃ¡ndose en ORDEN INVERSO - Timeline mostrando flujo de eventos con timestamps - ComparaciÃ³n lado a lado: mismo escenario con ambos patterns - Zoom en saga state storage (tabla en DB) - Destacar retry delays (1s â†’ 2s â†’ 4s exponential backoff) ## B-Roll Sugerido - Arquitecturas de sistemas reales con Sagas (Netflix, Uber Eats) - Dashboards de Temporal/Camunda mostrando sagas en ejecuciÃ³n - Diagramas de AWS Step Functions (orchestration managed) - CÃ³digo de proyectos open source (Axon Framework, NServiceBus) - Logs de compensaciÃ³n ejecutÃ¡ndose en producciÃ³n
        </div>
    </div>
</body>
</html>
