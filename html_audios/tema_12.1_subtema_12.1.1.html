<!DOCTYPE html>
<html lang="es-CO">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tema 12.1 Subtema 12.1.1</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            line-height: 1.8;
            font-size: 18px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .content {
            color: #333;
            text-align: justify;
        }
        .instructions {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .instructions h2 {
            margin-top: 0;
            color: #2980b9;
            font-size: 16px;
        }
        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tema 12.1 Subtema 12.1.1</h1>
        
        <div class="instructions">
            <h2>ğŸ“¢ Instrucciones para escuchar con voz Salome (Colombia)</h2>
            <ol>
                <li>Haz clic derecho en esta pÃ¡gina</li>
                <li>Selecciona <strong>"Leer en voz alta"</strong> o presiona <strong>Ctrl + Shift + U</strong></li>
                <li>En el panel de lectura, haz clic en <strong>Opciones de voz</strong> (âš™ï¸)</li>
                <li>Selecciona la voz: <strong>es-CO-SalomeNeural (Colombia)</strong></li>
                <li>Ajusta la velocidad a tu preferencia</li>
                <li>Presiona <strong>Play â–¶ï¸</strong> para comenzar</li>
            </ol>
        </div>
        
        <div class="content">
            Guion de Video: Events vs Commands vs Queries DuraciÃ³n: 25 minutos Nivel: Intermedio Requisitos previos: Conocimientos bÃ¡sicos de arquitectura de software --- ## IntroducciÃ³n [PANTALLA: TÃ­tulo animado] ğŸ¬ NarraciÃ³n: "Bienvenidos a este mÃ³dulo sobre Event-Driven Architecture. Hoy vamos a explorar uno de los conceptos mÃ¡s importantes en arquitecturas modernas: la diferencia entre Events, Commands y Queries. Si alguna vez te has preguntado por quÃ© Netflix puede manejar millones de usuarios simultÃ¡neos, o cÃ³mo Amazon procesa miles de pedidos por segundo sin perder consistencia, la respuesta estÃ¡ en arquitecturas event-driven. Al final de este video, entenderÃ¡s cuÃ¡ndo usar Events vs Commands, cÃ³mo aplicar principios SOLID a sistemas event-driven, y patrones cruciales como Outbox Pattern y Event-Carried State Transfer." [VISUAL: Logos de Netflix, Amazon, Uber] --- ## Problema: Â¿Por quÃ© necesitamos Events? [PANTALLA: CÃ³digo de arquitectura monolÃ­tica] ğŸ¬ NarraciÃ³n: "Comencemos con un problema real. Imagina que estÃ¡s construyendo un sistema de e-commerce tradicional." [VISUAL: CÃ³digo Java] ``java public class OrderService { public void createOrder(Order order) { orderRepository.save(order); inventoryService.reduceStock(order.items); emailService.sendConfirmation(order); analyticsService.trackSale(order); } } ` ğŸ¬ NarraciÃ³n: "Â¿Ves el problema? Este cÃ³digo viola el principio de Single Responsibility. Â¿QuÃ© pasa si el servicio de email falla? Â¿Se debe cancelar todo el pedido? Â¿QuÃ© pasa si necesitas agregar notificaciones SMS?" [VISUAL: Diagrama mostrando acoplamiento] "AdemÃ¡s, todo estÃ¡ fuertemente acoplado. Agregar una nueva funcionalidad requiere modificar este mÃ©todo, violando el principio Open/Closed." [ANIMACIÃ“N: Mostrar cascada de fallos] "Y lo peor: si cualquier servicio falla, el usuario tiene que esperar mientras todo se ejecuta sincrÃ³nicamente. Esto es lento e ineficiente." --- ## SoluciÃ³n: Commands vs Events [TRANSICIÃ“N: Arquitectura Event-Driven] ğŸ¬ NarraciÃ³n: "AquÃ­ es donde entran Commands y Events. Veamos las diferencias fundamentales." [PANTALLA: Tabla comparativa animada] | Aspecto | Command | Event | |---------|---------|-------| | Tiempo Verbal | Imperativo (CreateOrder) | Pasado (OrderCreated) | | Puede Fallar | âœ… SÃ­ | âŒ No (ya ocurriÃ³) | | Handlers | 1 (exactamente uno) | N (cero o mÃ¡s) | | IntenciÃ³n | "Haz esto" | "Esto ocurriÃ³" | ğŸ¬ NarraciÃ³n: "Un Command es una instrucciÃ³n: 'CreateOrder'. Puede fallar si el stock no existe. Tiene exactamente un handler que lo procesa." [VISUAL: AnimaciÃ³n de Command flow] ` Usuario â†’ CreateOrderCommand â†’ OrderHandler â†’ âœ…/âŒ ` "Un Event es un hecho inmutable: 'OrderCreated'. Ya ocurriÃ³, no puede fallar. Puede tener mÃºltiples handlers interesados." [VISUAL: AnimaciÃ³n de Event flow] ` OrderCreatedEvent â†’ â”¬â†’ InventoryHandler â”œâ†’ EmailHandler â”œâ†’ AnalyticsHandler â””â†’ NotificationHandler ` --- ## SOLID en Event-Driven [PANTALLA: CÃ³digo refactorizado] ğŸ¬ NarraciÃ³n: "Ahora refactoricemos nuestro cÃ³digo aplicando SOLID. Primero, el Single Responsibility Principle." [VISUAL: CÃ³digo TypeScript con animaciÃ³n] `typescript // SRP: Cada handler una responsabilidad class InventoryEventHandler implements EventHandler<OrderCreatedEvent> { async handle(event: OrderCreatedEvent): Promise<void> { await this.inventory.reduceStock(event.items); } } class NotificationEventHandler implements EventHandler<OrderCreatedEvent> { async handle(event: OrderCreatedEvent): Promise<void> { await this.email.send(event.customerId, 'Order created!'); } } ` ğŸ¬ NarraciÃ³n: "Cada handler tiene una sola responsabilidad. Si el email falla, el inventario ya se redujo. EstÃ¡n desacoplados." [TRANSICIÃ“N: Open/Closed Principle] `typescript // OCP: Extensible sin modificar EventBus class EventBus { private handlers = new Map<string, EventHandler[]>(); register<T>(eventType: string, handler: EventHandler<T>) { // Agregar handler sin modificar cÃ³digo existente } } // Agregar nuevo handler SIN cambiar EventBus eventBus.register('OrderCreated', new SMSHandler()); // âœ… ` ğŸ¬ NarraciÃ³n: "El EventBus es extensible sin modificar su cÃ³digo. Esto es Open/Closed Principle en acciÃ³n." [VISUAL: Dependency Inversion] `kotlin // DIP: Depender de abstracciones interface EventPublisher { suspend fun publish(event: DomainEvent) } class KafkaEventPublisher : EventPublisher { ... } class RabbitMQEventPublisher : EventPublisher { ... } ` --- ## Patrones Cruciales [PANTALLA: TÃ­tulo "Outbox Pattern"] ğŸ¬ NarraciÃ³n: "Ahora hablemos del Outbox Pattern. Este patrÃ³n resuelve un problema crÃ­tico: Â¿quÃ© pasa si guardas el pedido en la base de datos pero Kafka se cae antes de publicar el evento?" [VISUAL: Diagrama del problema] ` âŒ Problema: 1. db.save(order) âœ… 2. kafka.publish() âŒ (Kafka caÃ­do) Resultado: Pedido guardado, pero nadie se enterÃ³! ` ğŸ¬ NarraciÃ³n: "La soluciÃ³n: guardar el evento en una tabla outbox en la misma transacciÃ³n que el pedido." [ANIMACIÃ“N: Outbox Pattern flow] `java @Transactional public void createOrder(Order order) { // 1. Guardar pedido orderRepo.save(order); // 2. Guardar evento en outbox (misma transacciÃ³n) outboxRepo.save(new OutboxEvent( "OrderCreated", toJson(new OrderCreatedEvent(order)) )); // Commit atÃ³mico: ambos o ninguno } // 3. Proceso en background lee outbox y publica @Scheduled(fixedDelay = 5000) public void processOutbox() { List<OutboxEvent> pending = outboxRepo.findUnprocessed(); for (OutboxEvent event : pending) { kafka.publish(event); event.markProcessed(); } } ` ğŸ¬ NarraciÃ³n: "Con esto garantizamos at-least-once delivery. Si Kafka falla, el evento permanece en outbox y se reintentarÃ¡." [TRANSICIÃ“N: Event-Carried State Transfer] ğŸ¬ NarraciÃ³n: "Otro patrÃ³n importante: Event-Carried State Transfer. En lugar de enviar solo IDs, embebe los datos necesarios." [VISUAL: ComparaciÃ³n lado a lado] `typescript // âŒ Event Notification (solo IDs) interface BookingCreatedEventBad { bookingId: string; customerId: string; // Solo ID flightId: string; // Solo ID } // Consumidor necesita llamar APIs: const customer = await customerService.get(event.customerId); // 50ms const flight = await flightService.get(event.flightId); // 100ms // Total: 150ms + acoplamiento // âœ… Event-Carried State Transfer (datos embebidos) interface BookingCreatedEvent { bookingId: string; customer: { name: string; email: string; loyaltyTier: string; }, flight: { number: string; departure: FlightDetails; arrival: FlightDetails; } } // Consumidor tiene TODO: sendEmail(event.customer.email, renderTemplate(event)); // Total: 5ms, sin dependencias externas ` ğŸ¬ NarraciÃ³n: "El trade-off: eventos mÃ¡s grandes (2KB vs 200 bytes), pero 30x mÃ¡s rÃ¡pido y sin acoplamiento." --- ## DemostraciÃ³n PrÃ¡ctica [PANTALLA: Terminal + IDE] ğŸ¬ NarraciÃ³n: "Veamos esto en acciÃ³n. Voy a ejecutar nuestro sistema de Ã³rdenes con eventos." [DEMO: Ejecutar cÃ³digo] `bash $ npm test âœ“ EventBus supports multiple handlers âœ“ Handlers run in parallel âœ“ Error in one handler doesn't affect others âœ“ Outbox pattern guarantees delivery Performance Test: Event Notification: 150ms Event-Carried Transfer: 5ms Improvement: 30x faster âœ… `` ğŸ¬ NarraciÃ³n: "Como ven, los handlers corren en paralelo, los errores estÃ¡n aislados, y el Outbox Pattern garantiza entrega confiable." --- ## Resumen y Siguientes Pasos [PANTALLA: Puntos clave animados] ğŸ¬ NarraciÃ³n: "Recapitulemos los puntos clave: 1. Commands: Imperativos, pueden fallar, 1 handler 2. Events: Pasado, inmutables, N handlers 3. SOLID: SRP en handlers, OCP en EventBus, DIP en publishers 4. Outbox Pattern: GarantÃ­as transaccionales 5. State Transfer: Performance vs tamaÃ±o En el prÃ³ximo video exploraremos Event Sourcing: cÃ³mo guardar eventos en lugar de estado actual, y por quÃ© esto te da superpoderes como time travel y audit trail completo. Hasta la prÃ³xima!" [PANTALLA: Call to action] - ğŸ“š Material complementario en el repositorio - ğŸ’» Ejercicios prÃ¡cticos disponibles - ğŸ¯ PrÃ³ximo tema: Event Sourcing y CQRS --- ## Recursos Visuales ### Animaciones Clave: 1. Command flow: Usuario â†’ Command â†’ Handler (linear) 2. Event flow: Event â†’ MÃºltiples handlers (fan-out) 3. Outbox Pattern: DB transaction con outbox + background processor 4. Performance comparison: Event Notification vs State Transfer ### CÃ³digo a Mostrar: - TypeScript: EventBus implementation - Java: Outbox Pattern con Spring Boot - Python: Event handlers con SRP - Kotlin: DIP con EventPublisher interface ### Diagramas: 1. Arquitectura monolÃ­tica vs Event-Driven 2. Outbox Pattern sequence diagram 3. Event-Carried State Transfer comparison ## Notas para el Editor - Usar syntax highlighting para cÃ³digo - Animaciones suaves para transiciones - Zoom en puntos clave del cÃ³digo - Background music sutil (no distractiva) - SubtÃ­tulos para tÃ©rminos tÃ©cnicos
        </div>
    </div>
</body>
</html>
