<!DOCTYPE html>
<html lang="es-CO">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tema 13.3 Subtema 13.3.1</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            line-height: 1.8;
            font-size: 18px;
            background-color: #f5f5f5;
        }
        .container {
            background-color: white;
            padding: 40px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }
        .content {
            color: #333;
            text-align: justify;
        }
        .instructions {
            background-color: #e8f4f8;
            border-left: 4px solid #3498db;
            padding: 15px;
            margin: 20px 0;
            border-radius: 5px;
        }
        .instructions h2 {
            margin-top: 0;
            color: #2980b9;
            font-size: 16px;
        }
        .instructions ol {
            margin: 10px 0;
            padding-left: 20px;
        }
        .instructions li {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Tema 13.3 Subtema 13.3.1</h1>
        
        <div class="instructions">
            <h2>ğŸ“¢ Instrucciones para escuchar con voz Salome (Colombia)</h2>
            <ol>
                <li>Haz clic derecho en esta pÃ¡gina</li>
                <li>Selecciona <strong>"Leer en voz alta"</strong> o presiona <strong>Ctrl + Shift + U</strong></li>
                <li>En el panel de lectura, haz clic en <strong>Opciones de voz</strong> (âš™ï¸)</li>
                <li>Selecciona la voz: <strong>es-CO-SalomeNeural (Colombia)</strong></li>
                <li>Ajusta la velocidad a tu preferencia</li>
                <li>Presiona <strong>Play â–¶ï¸</strong> para comenzar</li>
            </ol>
        </div>
        
        <div class="content">
            Guion de Video: Serverless y Service Mesh DuraciÃ³n: 35 minutos Objetivo: Explicar serverless computing (AWS Lambda) y service mesh (Istio) con demos prÃ¡cticas --- ## IntroducciÃ³n Bienvenidos al mÃ³dulo de Serverless y Service Mesh, dos paradigmas que estÃ¡n revolucionando las arquitecturas cloud-native modernas. Serverless NO significa "sin servidores". Significa que tÃº no gestionas servidores. El cloud provider se encarga de infraestructura, OS, patches, scaling. Service Mesh es una capa de infraestructura que gestiona comunicaciÃ³n entre microservicios: load balancing, security, observability. Agenda: 1. AWS Lambda: Event-driven functions 2. Patrones serverless 3. Istio: Traffic management 4. Canary deployments 5. mTLS y security --- ## AWS Lambda Basics ### Â¿QuÃ© es Lambda? AWS Lambda ejecuta cÃ³digo en respuesta a eventos sin gestionar servidores. Triggers comunes: - HTTP requests (API Gateway) - S3 uploads - DynamoDB streams - CloudWatch Events (schedule) Demo: Hello World Lambda ``typescript // handler.ts import { APIGatewayProxyEvent, APIGatewayProxyResult } from "aws-lambda"; export const handler = async ( event: APIGatewayProxyEvent ): Promise<APIGatewayProxyResult> => { const name = event.queryStringParameters?.name || "World"; return { statusCode: 200, body: JSON.stringify({ message: Hello, ${name}!, timestamp: new Date().toISOString(), }), }; }; ` SAM Template: `yaml AWSTemplateFormatVersion: "2010-09-09" Transform: AWS::Serverless-2016-10-31 Resources: HelloWorldFunction: Type: AWS::Serverless::Function Properties: Runtime: nodejs18.x Handler: dist/handler.handler CodeUri: ./ Events: ApiEvent: Type: Api Properties: Path: /hello Method: get ` Deploy: `bash sam build sam deploy --guided # Test curl https://abc123.execute-api.us-east-1.amazonaws.com/Prod/hello?name=Alice # {"message":"Hello, Alice!","timestamp":"2024-01-15T10:30:00Z"} ` Key features: âœ… Auto-scaling: 0 â†’ 1000 invocaciones automÃ¡ticamente âœ… Pay-per-use: Solo pagas por tiempo de ejecuciÃ³n (milisegundos) âœ… Managed: AWS gestiona todo --- ## Patrones Serverless ### PatrÃ³n 1: API Backend (CRUD) ` Client â†’ API Gateway â†’ Lambda â†’ DynamoDB ` Demo: CRUD de Productos `typescript // src/handlers/products.ts import { DynamoDB } from "aws-sdk"; const dynamoDB = new DynamoDB.DocumentClient(); export const getProducts = async () => { const result = await dynamoDB .scan({ TableName: process.env.TABLE_NAME!, }) .promise(); return { statusCode: 200, body: JSON.stringify(result.Items), }; }; export const createProduct = async (event) => { const { name, price } = JSON.parse(event.body); const product = { id: Date.now().toString(), name, price, createdAt: new Date().toISOString(), }; await dynamoDB .put({ TableName: process.env.TABLE_NAME!, Item: product, }) .promise(); return { statusCode: 201, body: JSON.stringify(product), }; }; ` Test: `bash # Create product curl -X POST $API_URL/products \ -H "Content-Type: application/json" \ -d '{"name":"Laptop","price":999.99}' # Get products curl $API_URL/products # [{"id":"1234567890","name":"Laptop","price":999.99,"createdAt":"..."}] ` ### PatrÃ³n 2: Event Processing (S3 â†’ Lambda) ` S3 Upload â†’ Lambda (resize image) â†’ S3 (thumbnails) ` Demo: Image Processor `typescript // src/handlers/imageProcessor.ts import { S3Event } from "aws-lambda"; import AWS from "aws-sdk"; import sharp from "sharp"; const s3 = new AWS.S3(); export const handler = async (event: S3Event) => { for (const record of event.Records) { const key = record.s3.object.key; // Download image const original = await s3 .getObject({ Bucket: "my-bucket", Key: key, }) .promise(); // Resize to thumbnail const thumbnail = await sharp(original.Body as Buffer) .resize(200, 200) .toBuffer(); // Upload thumbnail await s3 .putObject({ Bucket: "my-bucket", Key: thumbnails/${key}, Body: thumbnail, }) .promise(); console.log(Thumbnail created: thumbnails/${key}); } }; ` Trigger configurado en SAM: `yaml ImageProcessorFunction: Type: AWS::Serverless::Function Events: S3Event: Type: S3 Properties: Bucket: !Ref ImageBucket Events: s3:ObjectCreated:* Filter: S3Key: Rules: - Name: prefix Value: uploads/ ` Test: `bash # Upload imagen aws s3 cp photo.jpg s3://my-bucket/uploads/photo.jpg # Lambda se ejecuta automÃ¡ticamente # Thumbnail en s3://my-bucket/thumbnails/photo.jpg ` Ventaja: Event-driven, solo se ejecuta cuando hay uploads. --- ## IntroducciÃ³n a Service Mesh ### Â¿QuÃ© es Service Mesh? En microservicios, cada servicio necesita: - Load balancing - Service discovery - Retries, timeouts - Circuit breaking - mTLS - Distributed tracing Problema: Implementar esto en cada servicio duplica cÃ³digo. SoluciÃ³n: Service Mesh gestiona todo esto fuera del cÃ³digo de la app. ### Istio Architecture ` Control Plane (istiod) â†“ config Data Plane (Envoy Sidecars) Pod 1 Pod 2 â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚ App â”‚ â”‚ App â”‚ â”‚ â”‚ â”‚ â”‚ â”‚ Envoy â†â”€â”¼â”€â”€â”€â”€â”¼â†’ Envoy â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ ` Envoy sidecar intercepta todo el trÃ¡fico de entrada y salida. InstalaciÃ³n: `bash # Descargar Istio curl -L https://istio.io/downloadIstio | sh - cd istio-1.20.0 # Instalar istioctl install --set profile=demo -y # Habilitar sidecar injection kubectl label namespace default istio-injection=enabled ` Verificar: `bash kubectl get pods -n istio-system # NAME READY STATUS RESTARTS AGE # istiod-7d8f5c9b7f-abc12 1/1 Running 0 2m # istio-ingressgateway-6f9d8c7b8f-def34 1/1 Running 0 2m ` --- ## Traffic Management: Canary Deployment Escenario: Tienes app v1 en producciÃ³n. Quieres desplegar v2 pero solo a 10% de usuarios inicialmente. ### Deployments `yaml # deployment-v1.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-v1 spec: replicas: 3 selector: matchLabels: app: myapp version: v1 template: metadata: labels: app: myapp version: v1 spec: containers: - name: myapp image: myapp:1.0.0 --- # deployment-v2.yaml apiVersion: apps/v1 kind: Deployment metadata: name: myapp-v2 spec: replicas: 1 selector: matchLabels: app: myapp version: v2 template: metadata: labels: app: myapp version: v2 spec: containers: - name: myapp image: myapp:2.0.0 ` ### Istio Configuration `yaml # virtual-service.yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: myapp-vs spec: hosts: - myapp-service http: - route: - destination: host: myapp-service subset: v1 weight: 90 - destination: host: myapp-service subset: v2 weight: 10 --- # destination-rule.yaml apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: myapp-dr spec: host: myapp-service subsets: - name: v1 labels: version: v1 - name: v2 labels: version: v2 ` Deploy: `bash kubectl apply -f deployment-v1.yaml kubectl apply -f deployment-v2.yaml kubectl apply -f service.yaml kubectl apply -f virtual-service.yaml kubectl apply -f destination-rule.yaml # Test: 100 requests for i in $(seq 1 100); do curl -s http://myapp-service/version | jq -r '.version' done | sort | uniq -c ` Resultado: ` 90 1.0.0 10 2.0.0 ` Istio distribuyÃ³ trÃ¡fico exactamente como configuramos. Incrementar a 50/50: `bash kubectl apply -f - <<EOF apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: myapp-vs spec: hosts: - myapp-service http: - route: - destination: host: myapp-service subset: v1 weight: 50 - destination: host: myapp-service subset: v2 weight: 50 EOF ` Finalmente 100% v2: `yaml weight: 0 # v1 weight: 100 # v2 ` Ventaja: Canary deployment sin cambios en el cÃ³digo, todo declarativo. --- ## Mutual TLS (mTLS) mTLS: AutenticaciÃ³n bidireccional con certificados. - TLS tradicional: Solo server tiene certificado (HTTPS) - mTLS: Cliente y server se autentican mutuamente Habilitar mTLS en Istio: `yaml # peer-authentication.yaml apiVersion: security.istio.io/v1beta1 kind: PeerAuthentication metadata: name: default namespace: default spec: mtls: mode: STRICT ` `bash kubectl apply -f peer-authentication.yaml ` Resultado: Todo el trÃ¡fico entre pods en default namespace estÃ¡ cifrado con mTLS. Verificar certificados: `bash istioctl proxy-config secret <pod-name> -o json | jq '.dynamicActiveSecrets' ` Veremos certificados X.509 generados automÃ¡ticamente por Istio. Beneficios: âœ… Zero-trust security âœ… RotaciÃ³n automÃ¡tica de certificados âœ… Sin cambios en cÃ³digo de la app --- ## Circuit Breaking Problema: Un servicio lento puede saturar todo el sistema. SoluciÃ³n: Circuit breaker expulsa pods fallidos temporalmente. `yaml # destination-rule-circuit-breaker.yaml apiVersion: networking.istio.io/v1beta1 kind: DestinationRule metadata: name: backend-circuit-breaker spec: host: backend-service trafficPolicy: connectionPool: tcp: maxConnections: 100 http: http1MaxPendingRequests: 50 outlierDetection: consecutiveErrors: 5 interval: 30s baseEjectionTime: 30s maxEjectionPercent: 50 ` Comportamiento: - Si un pod falla 5 requests consecutivos â†’ se expulsa del pool por 30s - MÃ¡ximo 50% de pods pueden estar expulsados Test: Simular servicio lento: `bash # Inyectar delay en un pod kubectl exec -it <backend-pod> -- killall -STOP node # Hacer requests for i in $(seq 1 100); do curl -s http://backend-service/api/data done # Istio detecta fallos y deja de enviar trÃ¡fico a ese pod ` --- ## Observability con Jaeger Istio integra con Jaeger para distributed tracing. `bash # Deploy Jaeger kubectl apply -f https://raw.githubusercontent.com/istio/istio/release-1.20/samples/addons/jaeger.yaml # Port-forward kubectl port-forward -n istio-system svc/jaeger 16686:16686 # Abrir browser open http://localhost:16686 ` Hacer requests para generar traces: `bash for i in $(seq 1 20); do curl http://myapp-service/api/products done ` En Jaeger UI: Veremos trace completo: ` User Request (200ms total) â†“ Frontend Service (10ms) â†“ Backend Service (50ms) â†“ Database Query (140ms) `` Sin cambios en cÃ³digo: Istio captura traces automÃ¡ticamente via sidecar proxies. --- ## Resumen Serverless (AWS Lambda): âœ… Event-driven, pay-per-use âœ… Auto-scaling automÃ¡tico âœ… Sin gestiÃ³n de servidores âœ… Ideal para cargas variables âŒ Cold start latency âŒ Timeout mÃ¡ximo (15 min) Service Mesh (Istio): âœ… Traffic management (canary, A/B testing) âœ… mTLS automÃ¡tico âœ… Circuit breaking âœ… Distributed tracing âœ… Todo declarativo, sin cambios en cÃ³digo âŒ Complejidad adicional âŒ Overhead de sidecars Casos de uso: - Serverless: APIs, event processing, scheduled tasks - Service Mesh: Microservicios complejos, multi-cloud, zero-trust security PrÃ³ximo tema: Observability y Monitoring con Prometheus, Grafana y OpenTelemetry. Gracias por ver este video.
        </div>
    </div>
</body>
</html>
